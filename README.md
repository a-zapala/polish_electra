# plElectra

## Introduction

**ELECTRA** is a method for self-supervised language representation learning using relatively little compute. ELECTRA models are trained to distinguish "real" input tokens vs "fake" input tokens generated by another neural network, similar to the discriminator of a [GAN](https://arxiv.org/pdf/1406.2661.pdf).

**plElectra** is pre-trained ELECTRA-small model for Polish language.

This repository contains code to pre-train ELECTRA, including small ELECTRA models on a single GPU. It also supports fine-tuning ELECTRA on downstream tasks including classification tasks (e.g,. [GLUE](https://gluebenchmark.com/), [KLEJ](https://klejbenchmark.com)), QA tasks (e.g., [SQuAD](https://rajpurkar.github.io/SQuAD-explorer/)), and sequence tagging tasks (e.g., [text chunking](https://www.clips.uantwerpen.be/conll2000/chunking/)).




## Model

Summary of our best model:

| Model name | Model architecture | Vocab | Layers | Hidden Size | Masking | Params | KLEJ score (test set) |
| --- | --- | --- | --- | ---  | --- | --- | --- |
| plElectra | ELECTRA-small | Allegro's HerBERT | 12 | 256 | 0.15 | 14M | todo |

All models were trained on a single GPU. For training purposes we utilized corpus incorporating three different data sources:
* set of required reading for Polish schools [WolneLektury](https://wolnelektury.pl/),
* National Corpus of Polish [NKJP](http://nkjp.pl),
* [Wikipedia](https://pl.wikipedia.org/wiki/Wikipedia:Strona_główna).

Please note that since we failed at creating good quality vocabulary set, we did not utilize standard Electra's tokenizer in our final model. Instead we decided to take advantage of [herbert-base-cased](https://huggingface.co/allegro/herbert-base-cased) tokenizer's vocabulary, which improved model's quality on downstream tasks.

### Detailed KLEJ results

|  | AR | CBD | CDSC-E | CDSC-R  | DYK  | NKJP | PolEmo2.0-IN | PolEmo2.0-OUT | PSC |
| --- | --- | --- | --- | ---  | ---  | --- | --- | --- | ---|
| plElectra| - | - | - | - | - | - | - | - | - | - |


## Requirements
* Python 3
* [TensorFlow](https://www.tensorflow.org/) 1.15 (although we hope to support TensorFlow 2.0 at a future date)
* [NumPy](https://numpy.org/)
* [scikit-learn](https://scikit-learn.org/stable/) and [SciPy](https://www.scipy.org/) (for computing some evaluation metrics).

## Pre-training
Use `build_pretraining_dataset.py` to create a pre-training dataset from a dump of raw text. It has the following arguments:

* `--corpus-dir`: A directory containing raw text files to turn into ELECTRA examples. A text file can contain multiple documents with empty lines separating them.
* `--vocab-file`: File defining the wordpiece vocabulary.
* `--output-dir`: Where to write out ELECTRA examples.
* `--max-seq-length`: The number of tokens per example (128 by default).
* `--num-processes`: If >1 parallelize across multiple processes (1 by default).
* `--blanks-separate-docs`: Whether blank lines indicate document boundaries (True by default).
* `--do-lower-case/--no-lower-case`: Whether to lower case the input text (True by default).

Use `run_pretraining.py` to pre-train an ELECTRA model. It has the following arguments:

* `--data-dir`: a directory where pre-training data, model weights, etc. are stored. By default, the training loads examples from `<data-dir>/pretrain_tfrecords` and a vocabulary from `<data-dir>/vocab.txt`.
*  `--model-name`: a name for the model being trained. Model weights will be saved in `<data-dir>/models/<model-name>` by default.
* `--hparams` (optional): a JSON dict or path to a JSON file containing model hyperparameters, data paths, etc. See `configure_pretraining.py` for the supported hyperparameters.

If training is halted, re-running the `run_pretraining.py` with the same arguments will continue the training where it left off.

You can continue pre-training from the released ELECTRA checkpoints by
1. Setting the model-name to point to a downloaded model (e.g., `--model-name electra_small` if you downloaded weights to `$DATA_DIR/electra_small`).
2. Setting `num_train_steps` by (for example) adding `"num_train_steps": 4010000` to the `--hparams`. This will continue training the small model for 10000 more steps (it has already been trained for 4e6 steps).
3. Increase the learning rate to account for the linear learning rate decay. For example, to start with a learning rate of 2e-4 you should set the `learning_rate` hparam to 2e-4 * (4e6 + 10000) / 10000.
4. For ELECTRA-Small, you also need to specifiy `"generator_hidden_size": 1.0` in the `hparams` because we did not use a small generator for that model.


To customize the training, add `--hparams '{"hparam1": value1, "hparam2": value2, ...}'` to the run command. `--hparams` can also be a path to a `.json` file containing the hyperparameters. Some particularly useful options:

* `"debug": true` trains a tiny ELECTRA model for a few steps.
* `"model_size": one of "small", "base", or "large"`: determines the size of the model
* `"electra_objective": false` trains a model with masked language modeling instead of replaced token detection (essentially BERT with dynamic masking and no next-sentence prediction).
* `"num_train_steps": n` controls how long the model is pre-trained for.
* `"pretrain_tfrecords": <paths>` determines where the pre-training data is located. Note you need to specify the specific files not just the directory (e.g., `<data-dir>/pretrain_tf_records/pretrain_data.tfrecord*`)
* `"vocab_file": <path>` and `"vocab_size": n` can be used to set a custom wordpiece vocabulary.
* `"learning_rate": lr, "train_batch_size": n`, etc. can be used to change training hyperparameters
* `"model_hparam_overrides": {"hidden_size": n, "num_hidden_layers": m}`, etc. can be used to changed the hyperparameters for the underlying transformer (the `"model_size"` flag sets the default values).

See `configure_pretraining.py` for the full set of supported hyperparameters.

#### Evaluating the pre-trained model.

To evaluate the model on a downstream task, see the below finetuning instructions. To evaluate the generator/discriminator on the openwebtext data run `python3 run_pretraining.py --data-dir $DATA_DIR --model-name electra_small_owt --hparams '{"do_train": false, "do_eval": true}'`. This will print out eval metrics such as the accuracy of the generator and discriminator, and also writing the metrics out to `data-dir/model-name/results`.

## Fine-tuning

Use `run_finetuning.py` to fine-tune and evaluate an ELECTRA model on a downstream NLP task. It expects three arguments:

* `--data-dir`: a directory where data, model weights, etc. are stored. By default, the script loads finetuning data from `<data-dir>/finetuning_data/<task-name>` and a vocabulary from `<data-dir>/vocab.txt`.
*  `--model-name`: a name of the pre-trained model: the pre-trained weights should exist in `data-dir/models/model-name`.
* `--hparams`: a JSON dict containing model hyperparameters, data paths, etc. (e.g., `--hparams '{"task_names": ["rte"], "model_size": "base", "learning_rate": 1e-4, ...}'`). See `configure_pretraining.py` for the supported hyperparameters.  Instead of a dict, this can also be a path to a `.json` file containing the hyperparameters. You must specify the `"task_names"` and `"model_size"` (see examples below).

Eval metrics will be saved in `data-dir/model-name/results` and model weights will be saved in `data-dir/model-name/finetuning_models` by default. Evaluation is done on the dev set by default. To customize the training, add `--hparams '{"hparam1": value1, "hparam2": value2, ...}'` to the run command. Some particularly useful options:

* `"debug": true` fine-tunes a tiny ELECTRA model for a few steps.
* `"task_names": ["task_name"]`: specifies the tasks to train on. A list because the codebase nominally supports multi-task learning, (although be warned this has not been thoroughly tested).
* `"model_size": one of "small", "base", or "large"`: determines the size of the model; you must set this to the same size as the pre-trained model.
* `"do_train" and "do_eval"`: train and/or evaluate a model (both are set to true by default). For using `"do_eval": true` with `"do_train": false`, you need to specify the `init_checkpoint`, e.g., `python3 run_finetuning.py --data-dir $DATA_DIR --model-name electra_base --hparams '{"model_size": "base", "task_names": ["mnli"], "do_train": false, "do_eval": true, "init_checkpoint": "<data-dir>/models/electra_base/finetuning_models/mnli_model_1"}'`
* `"num_trials": n`: If >1, does multiple fine-tuning/evaluation runs with different random seeds.
* `"learning_rate": lr, "train_batch_size": n`, etc. can be used to change training hyperparameters.
* `"model_hparam_overrides": {"hidden_size": n, "num_hidden_layers": m}`, etc. can be used to changed the hyperparameters for the underlying transformer (the `"model_size"` flag sets the default values).


### Finetune ELECTRA on a KLEJ task

Download the KLEJ data by running [this script](https://github.com/allegro/klejbenchmark-baselines/blob/master/scripts/download_klej.sh). Set up the data by running `mv klej_ar ar && klej_cbd cbd && klej_cdsc-e cdsc-e && klej_cdsc-r cdsc-r && klej_dyk dyk && klej_nkjp-ner nkjp-ner && klej_polemo2.0-in polemo-in && klej_polemo2.0-out polemo-out && klej_psc psc && mv * $DATA_DIR/finetuning_data`.

Then run `run_finetuning.py`. For example, to fine-tune ELECTRA-small  on NKJP-NER
```
python3 run_finetuning.py --data-dir $DATA_DIR --model-name polish_electra --hparams '{"model_size": "small", "task_names": ["nkjp-ner"]}'
```

### Adding a new task
The easiest way to run on a new task is to implement a new `finetune.task.Task`, add it to `finetune.task_builder.py`, and then use `run_finetuning.py` as normal. For classification/qa/sequence tagging, you can inherit from a `finetune.classification.classification_tasks.ClassificationTask`, `finetune.qa.qa_tasks.QATask`, or `finetune.tagging.tagging_tasks.TaggingTask`.
For preprocessing data, we use the same tokenizer as [BERT](https://github.com/google-research/bert).


## Citation
If you use this code for your publication, please cite the original paper:
```
@inproceedings{clark2020electra,
  title = {{ELECTRA}: Pre-training Text Encoders as Discriminators Rather Than Generators},
  author = {Kevin Clark and Minh-Thang Luong and Quoc V. Le and Christopher D. Manning},
  booktitle = {ICLR},
  year = {2020},
  url = {https://openreview.net/pdf?id=r1xMH1BtvB}
}
```

If you use the code for Electric, please cite the Electric paper:
```
@inproceedings{clark2020electric,
  title = {Pre-Training Transformers as Energy-Based Cloze Models},
  author = {Kevin Clark and Minh-Thang Luong and Quoc V. Le and Christopher D. Manning},
  booktitle = {EMNLP},
  year = {2020},
  url = {https://www.aclweb.org/anthology/2020.emnlp-main.20.pdf}
}
```
